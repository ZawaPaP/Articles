---
title: PythonでのDebug方法 (もう`print()` は使わない)
tags:
  - debug
  - Python3
  - logging
private: false
updated_at: '2023-01-22T13:41:07+09:00'
id: 3675e1ae817e5dbe7969
organization_url_name: null
slide: false
ignorePublish: false
---
tl,dr;
-
* コードのデバッグに`print()`はデメリットが多いため使わない
* 代わりに`Logging`を使う
* ベストプラクティスがありそうだが、わからない

Summary 
-
プログラムを書くときに不可避のエラー。これまでは、エラーが発生した際にはエラーメッセージを元にコードの怪しいと思われる箇所に `print('check')` などと入れることで、エラー箇所の特定を行なっていた。しかし、これはどうにもエンジニアっぽくない。そしてなんかダサい。
というわけで、脱`print()`の方法を探すと、`Logging`というデバッグ用の基本モジュールがPythonには用意されていた。
Logging HOWTO: https://docs.python.org/3/howto/logging.html

Why use logging (don't use `print()`)
-
`print()`を使うデメリット
* 効率性の問題
    * `print('checkpoint 1')`など内容をユニークにして打ち込む必要がある。怪しい箇所がすぐに特定できない場合は、大量にコード内に`print()`を入れる必要がある。かつ、挿入箇所を自分で覚えている必要がある。。。。
    * コードが長くなるほど、作業時間が増え効率性が落ちる
* 表示の問題
    * stdout(console)に表示されるため邪魔  
    * バグ修正した後に、最後に全ての`print()`を消すという作業が発生する。しかしもし追加コードを書き、バグが起こったら再度`print()`を書く、、、、以下略 
* 保存性の問題
    * `print()`しているだけなので、保存されない

`Logging`のメリット
* 上記を解決できる

How
-
基本的には公式リフェレンスに書いてある通りだが、`import logging`をした後に、表示させたい level, format, filepathなどを指定し、`print`の代わりに`Logger`クラスインスタンスを呼び出す。
ex. `logger.debug`
```python
import logging

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
f = logging.Formatter('%(asctime)s - %(levelname)s - %(name)s - %(message)s')
fh = logging.FileHandler('./log/test.log')
fh.setFormatter(f)
logger.addHandler(fh) 

    def read(self):
        logger.debug('Start of read')
        ...
```

Next Action
-
**Start**
* 今後は`print()`ではなく、`Logging`を使ってdebugしていく

**Stop**
* コードがエラーを起こした時に、脳死的に`print()`を使うのをやめる

**homework**
* いま学んでいる`Try - except`や`unittest`とうまく組み合わせる方法を知りたい。
